from rasa_sdk import Tracker, Action
from rasa_sdk.executor import CollectingDispatcher
from typing import Dict, Text, Any, List
from rasa_sdk.events import SlotSet, ReminderScheduled, AllSlotsReset
from neo4j import GraphDatabase
import datetime
import random
from thefuzz import process  # Import the necessary module from thefuzz
import re


# def print_friends(tx, name):
#     names = []
#     for record in tx.run("MATCH (a:WRITER)-[:MARRIEDTO]->(friend:WRITER) WHERE a.name = $name "
#                          "RETURN friend.name ORDER BY friend.name", name=name):
#         print("record friend.name: {}".format(record["friend.name"]))
#         print("record: {}".format(record))
#         names.append(record["friend.name"])
#         print("names: ", names)
#
#         # return record["friend.name"]
#
#     return record["friend.name"]


def print_books_type(tx, book_type_pl):
    books_names_list = []

    # Query without ORDER BY rand()
    for record in tx.run(
            "MATCH (a:WRITER)-[:WROTE]->(book) "
            "WHERE a.name = 'ÎÎ¯ÎºÎ¿Ï‚ ÎšÎ±Î¶Î±Î½Ï„Î¶Î¬ÎºÎ·Ï‚' AND book.type_pl = $book_type_pl "
            "RETURN book.name AS name", book_type_pl=book_type_pl):
        books_names_list.append(record["name"])

    # Randomly select up to 5 books
    random_books_list = random.sample(books_names_list, min(len(books_names_list), 5))

    # Return the count and the random selection
    count_book_type_list = len(books_names_list)
    return count_book_type_list, random_books_list


# def print_halls(tx, hall_name, exhibits_collection):
#     exhibition_names_list = []
#     exhibition_url_list = []
#
#     # Check if exhibits_collection is provided
#     if exhibits_collection is not None:
#         query = (
#             "MATCH (exhibits:EXHIBIT) - [:ISLOCATEDIN] -> (hall:HALL) "
#             "WHERE hall.name = $hall_name AND exhibits.collection = $exhibits_collection "
#             "RETURN exhibits.name AS name, exhibits.url AS url"
#         )
#         params = {"hall_name": hall_name, "exhibits_collection": exhibits_collection}
#     else:
#         query = (
#             "CALL { "
#             "    MATCH (exhibits:EXHIBIT) - [:ISLOCATEDIN] -> (hall:HALL) "
#             "    WHERE hall.name = $hall_name "
#             "    RETURN exhibits.name AS name, exhibits.url AS url "
#             "    ORDER BY rand() "
#             "    LIMIT 5 "
#             "} "
#             "RETURN name, url"
#         )
#         params = {"hall_name": hall_name}
#         print("params: ", params)
#
#     for record in tx.run(query, **params):
#         exhibition_names_list.append(record["name"])
#         exhibition_url_list.append(record["url"])
#         print("exhibition_names: ", exhibition_names_list)
#         print("exhibition_url_list: ", exhibition_url_list)
#
#     return exhibition_names_list, exhibition_url_list

def print_halls(tx, hall_name, exhibits_collection):
    exhibition_names_list = []
    exhibition_url_list = []

    # Query without ORDER BY rand()
    if exhibits_collection is not None:
        query = (
            "MATCH (exhibits:EXHIBIT) - [:ISLOCATEDIN] -> (hall:HALL) "
            "WHERE hall.name = $hall_name AND exhibits.collection = $exhibits_collection "
            "RETURN exhibits.name AS name, exhibits.url AS url"
        )
        params = {"hall_name": hall_name, "exhibits_collection": exhibits_collection}
    else:
        query = (
            "MATCH (exhibits:EXHIBIT) - [:ISLOCATEDIN] -> (hall:HALL) "
            "WHERE hall.name = $hall_name "
            "RETURN exhibits.name AS name, exhibits.url AS url"
        )
        params = {"hall_name": hall_name}

    records = list(tx.run(query, **params))
    print("records list: ", records)

    # Use Python's random.sample to select 5 random records
    if records:
        sampled_records = random.sample(records, min(len(records), 5))
        for record in sampled_records:
            exhibition_names_list.append(record["name"])
            exhibition_url_list.append(record["url"])

    return exhibition_names_list, exhibition_url_list


def print_collection(tx, exhibits_collection):
    exhibition_names_list = []

    # Check if exhibits_collection is provided
    if exhibits_collection is not None:
        for record in tx.run(
                "MATCH (exhibits:EXHIBIT) - [:ISLOCATEDIN] -> (hall:HALL) "
                "WHERE exhibits.collection = $exhibits_collection "
                "RETURN exhibits.name AS name",
                exhibits_collection=exhibits_collection):
            exhibition_names_list.append(record["name"])

    # Randomly select up to 5 exhibits
    random_exhibits_list = random.sample(exhibition_names_list, min(len(exhibition_names_list), 5))

    # Return the random selection
    return random_exhibits_list


def print_collection_and_showcase(tx, exhibits_collection, exhibits_showcase):
    exhibition_names_list = []
    exhibition_url_list = []

    exhibits_showcase = int(exhibits_showcase)

    # Check if both exhibits_collection and exhibits_showcase are provided
    if exhibits_collection is not None and exhibits_showcase is not None:
        for record in tx.run(
                "MATCH (exhibits:EXHIBIT) "
                "WHERE exhibits.collection = $exhibits_collection AND exhibits.showcase = $exhibits_showcase "
                "RETURN exhibits.name AS name, exhibits.url AS url",
                exhibits_collection=exhibits_collection, exhibits_showcase=exhibits_showcase):
            exhibition_names_list.append(record["name"])
            exhibition_url_list.append(record["url"])

    # Combine names and URLs into pairs and sample up to 5 random pairs
    exhibit_pairs = list(zip(exhibition_names_list, exhibition_url_list))
    random_exhibits = random.sample(exhibit_pairs, min(len(exhibit_pairs), 5))

    # Unpack random pairs back into separate lists for names and URLs
    random_exhibition_names, random_exhibition_urls = zip(*random_exhibits) if random_exhibits else ([], [])

    return list(random_exhibition_names), list(random_exhibition_urls)


def print_floor(tx, floor):
    exhibition_names_list = []
    exhibition_url_list = []

    # print("print_floor:", floor)

    # Î¤ÏƒÎµÎºÎ¬ÏÏ‰ Î±Î½ ÎµÎ¯Î½Î±Î¹ None Î³Î¹Î±Ï„Î¯ Î¼Ï€Î¿ÏÎµÎ¯ ÎºÎ¬Ï€Î¿Î¹Î¿Ï‚ Î½Î± ÎºÎ¬Î½ÎµÎ¹ query Ï‡Ï‰ÏÎ¯Ï‚ Î½Î± ÏÏ‰Ï„Î®ÏƒÎµÎ¹ Î³Î¹Î± ÏƒÏ…Î³ÎºÎµÎºÏÎ¹Î¼Î­Î½Î¿ collection
    if floor is not None:
        for record in tx.run(
                "MATCH (exhibits:EXHIBIT) - [:ISLOCATEDIN] -> (hall:HALL)"
                "WHERE hall.floor = $floor "
                "RETURN exhibits.name, exhibits.url",
                floor=floor):
            exhibition_names_list.append((record["exhibits.name"]))
            exhibition_url_list.append((record["exhibits.url"]))

        # return record["book.name"]

    # print("exhibition_names_list: ", exhibition_names_list)
    # print("exhibition_url_list: ", exhibition_url_list)

    return exhibition_names_list, exhibition_url_list


# def print_complete_graph(tx, husband, has_wife, has_written):
#     for record in tx.run("MATCH (a:Person{name: $husband})-[has_written:HAS_WRITTEN{name: $has_written}]->(book:Book)"
#                          "MATCH (a:Person{name: $husband})-[has_wife:HAS_WIFE{name: $has_wife}]->(wife:Person)"
#                          "RETURN wife.name, book.name, has_wife.name, has_written.name ORDER BY book.name",
#                          husband=husband, has_wife=has_wife, has_written=has_written):
#         print("wife: {}, book: {}, has_wife: {}, has_written: {}".format(record["wife.name"], record["book.name"],
#                                                                          record["has_wife.name"],
#                                                                          record["has_written.name"]))
#     return record["wife.name"], record["book.name"], record["has_wife.name"], record["has_written.name"]


# Etsi eftiaksa to query se CYPHER
# MERGE (a:Person{name: "ÎÎ¯ÎºÎ¿Ï‚ ÎšÎ±Î¶Î±Î½Ï„Î¶Î¬ÎºÎ·Ï‚"})-[has_written:HAS_WRITTEN{name: "Î­Î³ÏÎ±ÏˆÎµ"}]->(book:Book{name: "ÎŸ ÎšÎ±Ï€ÎµÏ„Î¬Î½ ÎœÎ¹Ï‡Î¬Î»Î·Ï‚"})
# MERGE (a)-[has_wife:HAS_WIFE{name: "ÏƒÏÎ¶Ï…Î³Î¿"}]->(friend:Person{name: "Î•Î»Î­Î½Î· ÎšÎ±Î¶Î±Î½Ï„Î¶Î¬ÎºÎ·"})

# Dictionary of known entities and their corresponding functions
ENTITY_FUNCTION_MAPPING = {
    'ÎÎ¯ÎºÎ¿Ï‚ ÎšÎ±Î¶Î±Î½Ï„Î¶Î¬ÎºÎ·Ï‚': 'print_friends',
    'Î¼Ï…Î¸Î¹ÏƒÏ„Î¿ÏÎ®Î¼Î±Ï„Î±': 'print_books_type',
    'Ï€Î¿Î¹Î®Î¼Î±Ï„Î±': 'print_books_type',
    'Ï„Î±Î¾Î¹Î´Î¹Ï‰Ï„Î¹ÎºÎ¬': 'print_books_type',
    'Î¸ÎµÎ±Ï„ÏÎ¹ÎºÎ¬': 'print_books_type',
    'TRAVELEDTO': 'print_location_countries',
    'Ï†Î¯Î»Î¿Ï‚': 'print_friends_type',
    'ÏƒÏ…Î³Î³ÎµÎ½Î®Ï‚': 'print_relatives_type',
}

# List of known book titles for fuzzy matching
KNOWN_HALLS = [
    'Î’Î¹Î¿Î³ÏÎ±Ï†Î¹ÎºÎ¬',
    'Î˜Î­Î±Ï„ÏÎ¿',
    'ÎŸÎ´ÏÏƒÏƒÎµÎ¹Î±',
    'Î‘Î¯Î¸Î¿Ï…ÏƒÎ± Ï€ÏÎ¿Î²Î¿Î»ÏÎ½',
    'ÎœÏ…Î¸Î¹ÏƒÏ„Î¿ÏÎ®Î¼Î±Ï„Î±',
    'Î•Î¯ÏƒÎ¿Î´Î¿Ï‚',
    'Î“Î»Ï…Ï€Ï„Î¿Î¸Î®ÎºÎ·',
]

KNOWN_COLLECTIONS = [
    'Î‘Ï…Ï„ÏŒÎ³ÏÎ±Ï†Î±',
    'Î ÏÎ¿ÏƒÏ‰Ï€Î¹ÎºÎ¬ Î‘Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î±',
    'ÎˆÏÎ³Î± Ï„Î­Ï‡Î½Î·Ï‚',
    'ÎˆÎ³Î³ÏÎ±Ï†Î±',
    'Î•Ï€Î¹ÏƒÏ„Î¿Î»Î¹ÎºÏŒ Î‘ÏÏ‡ÎµÎ¯Î¿',
    'ÎˆÎ½Ï„Ï…Ï€Î±',
    'Î¦Ï‰Ï„Î¿Î³ÏÎ±Ï†Î¹ÎºÏŒ Î‘ÏÏ‡ÎµÎ¯Î¿',
]

KNOWN_FLOORS = [
    'Î™ÏƒÏŒÎ³ÎµÎ¹Î¿',
    '1Î¿Ï‚',
    'Î£ÎºÎ¬Î»Î±'
]


def get_relationship_2_variables(slot_based_query1, slot_based_query2):
    function_to_call = None  # Initialize function_to_call

    driver = GraphDatabase.driver("neo4j://node-3psivztn46ny2.eastus.cloudapp.azure.com:7687",
                                  auth=("neo4j", "P7yK77+(s@#[k"))  # Gia Docker connection

    # print("driver.verify_connectivity(): ", driver.verify_connectivity())

    def process_query(query):
        query = str(query)

        # Regex to match numbers with 1 to 3 digits
        number_pattern = re.match(r'^\d{1,3}$', query)

        if number_pattern:
            # If the query is a number (1 to 3 digits), return the corresponding function name
            # print(f"Matched a number: {query}")
            return query, 'print_collection_and_showcase'
        else:
            # print("query:", query)
            # print("type query:", type(query))

            # Fuzzy match against known halls and collections
            halls_match, halls_score = process.extractOne(query, KNOWN_HALLS)
            # print("halls_score:", halls_score)
            # print("halls_match:", halls_match)

            collection_match, collection_score = process.extractOne(query, KNOWN_COLLECTIONS)
            # print("collection_score:", collection_score)
            # print("collection_match:", collection_match)

            if halls_score >= 60:
                return halls_match, 'print_halls'
            elif collection_score >= 60:
                return collection_match, 'print_halls'  # Calling `print_halls` for collections
            else:
                print(f"Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎµ Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¯Ï‡Î¹ÏƒÎ· Î³Î¹Î±: {query}")
                return None, None

    # Process slot_based_query1
    if isinstance(slot_based_query1, list):
        slot_based_query1 = slot_based_query1[0]
        # print("slot_based_query1[0]:", slot_based_query1)
    else:
        print("The variable is not a list.")

    match1, function1 = process_query(slot_based_query1)

    # Process slot_based_query2
    if isinstance(slot_based_query2, list):
        slot_based_query2 = slot_based_query2[0]
        # print("slot_based_query2[0]:", slot_based_query2)
    else:
        print("The variable is not a list.")

    match2, function2 = process_query(slot_based_query2)

    # Determine final matches and functions
    if function1 == 'print_halls':
        # final_match = match1 if match1 else match2
        # showcase_match = match2 if match1 is None and match2 is not None else None
        final_match = match1
        showcase_match = match2
        # print("match1: ", final_match)
        # print("match2: ", showcase_match)
    else:
        final_match = match1 if match1 else match2
        showcase_match = None

    function_to_call = function1 if function1 else function2

    # print("final_match:", final_match)
    # print("showcase_match:", showcase_match)
    # print("function_to_call:", function_to_call)

    with driver.session() as session:
        if function_to_call == 'print_collection_and_showcase':
            query_exhibition_names, query_exhibition_url = session.read_transaction(
                print_collection_and_showcase, final_match, showcase_match
            )
        elif function_to_call == 'print_halls':
            query_exhibition_names, query_exhibition_url = session.read_transaction(
                print_halls, final_match, showcase_match
            )
        driver.close()
        return query_exhibition_names, query_exhibition_url


def check_collection_and_showcase(collection_match, showcase_match):
    """
    Check if both collection and showcase variables are not None and showcase is a valid 3-digit number.
    """
    if collection_match and showcase_match and re.match(r'^\d{1,3}$', showcase_match):
        return True
    return False


def process_query(query):
    query = str(query)

    # Regex to match numbers with 1 to 3 digits
    number_pattern = re.match(r'^\d{1,3}$', query)

    if number_pattern:
        # If the query is a number (1 to 3 digits), assume it is a showcase variable
        print(f"Matched a number: {query}")
        return None, query  # No collection match, only showcase match
    else:
        # print("query:", query)
        # print("type query:", type(query))

        # Fuzzy match against known collections
        collection_match, collection_score = process.extractOne(query, KNOWN_COLLECTIONS)
        # print("collection_score:", collection_score)
        # print("collection_match:", collection_match)

        if collection_score >= 60:
            return collection_match, None  # No showcase match, only collection match
        else:
            print(f"Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎµ Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¯Ï‡Î¹ÏƒÎ· Î³Î¹Î±: {query}")
            return None, None


def get_relationship_collection_with_showcase(slot_based_query1, slot_based_query2):
    driver = GraphDatabase.driver("neo4j://node-3psivztn46ny2.eastus.cloudapp.azure.com:7687",
                                  auth=("neo4j", "P7yK77+(s@#[k"))  # Gia Docker connection

    # Process slot_based_query1
    if isinstance(slot_based_query1, list):
        slot_based_query1 = slot_based_query1[0]
        # print("slot_based_query1[0]:", slot_based_query1)
    else:
        print("The variable is not a list.")

    collection_match1, showcase_match1 = process_query(slot_based_query1)

    # Process slot_based_query2
    if isinstance(slot_based_query2, list):
        slot_based_query2 = slot_based_query2[0]
        # print("slot_based_query2[0]:", slot_based_query2)
    else:
        print("The variable is not a list.")

    collection_match2, showcase_match2 = process_query(slot_based_query2)

    # Determine final matches and check for valid collection and showcase
    final_collection_match = collection_match1 if collection_match1 else collection_match2
    final_showcase_match = showcase_match1 if showcase_match1 else showcase_match2

    if check_collection_and_showcase(final_collection_match, final_showcase_match):
        function_to_call = 'print_collection_and_showcase'
    else:
        function_to_call = None  # or handle the case where `function_to_call` is not set

    # print("final_collection_match:", final_collection_match)
    # print("final_showcase_match:", final_showcase_match)
    # print("function_to_call:", function_to_call)

    with driver.session() as session:
        if function_to_call == 'print_collection_and_showcase':
            query_exhibition_names, query_exhibition_url = session.read_transaction(
                print_collection_and_showcase, final_collection_match, final_showcase_match
            )
            driver.close()
            return query_exhibition_names, query_exhibition_url
        else:
            # Handle the case where no valid function is determined
            driver.close()
            return [], []  # Or another appropriate response


def get_relationship_1_variable(slot_based_query):
    function_to_call = None  # Initialize function_to_call

    driver = GraphDatabase.driver("neo4j://node-3psivztn46ny2.eastus.cloudapp.azure.com:7687",
                                  auth=("neo4j", "P7yK77+(s@#[k"))  # Gia Docker connection
    # print("driver.verify_connectivity(): ", driver.verify_connectivity())
    #
    # print("slot_based_query: ", slot_based_query)

    if isinstance(slot_based_query, list):
        slot_based_query = slot_based_query[0]
    else:
        print("The variable is not a list.")

    # function_to_call = None  # Initialize function_to_call

    # Check if the input is a four-digit year using regex for publication year
    year_pattern = re.match(r'^\d{4}$', slot_based_query)
    if year_pattern:
        # Directly assign the function if it's a year
        function_to_call = 'print_publicationyear'
    else:
        # Use fuzzy matching to find the closest entity
        # closest_match, match_score = process.extractOne(slot_based_query, ENTITY_FUNCTION_MAPPING.keys())
        # print("match_score: ", match_score)

        # Fuzzy match against book titles
        collection_match, collection_score = process.extractOne(slot_based_query, KNOWN_COLLECTIONS)

        # Fuzzy match against book titles
        floor_match, floor_score = process.extractOne(slot_based_query, KNOWN_FLOORS)

        # if match_score >= 60 and (match_score >= floor_score or floor_score < 60):
        #     # Choose entity function if it has higher or equal score and is above the threshold
        #     slot_based_query = closest_match
        #     function_to_call = ENTITY_FUNCTION_MAPPING.get(slot_based_query)
        #     # print("function_to_call (entity): ", function_to_call)
        if collection_score >= 60:
            # Choose collection function if it has higher score and is above the threshold
            ENTITY_FUNCTION_MAPPING[slot_based_query] = 'print_collection'
            function_to_call = 'print_collection'
            slot_based_query = collection_match
            # print("function_to_call (collection): ", function_to_call)
        elif floor_score >= 60:
            # Choose book title function if it has higher score and is above the threshold
            ENTITY_FUNCTION_MAPPING[slot_based_query] = 'print_floor'
            function_to_call = 'print_floor'
            slot_based_query = floor_match
            # print("function_to_call (book title): ", function_to_call)
        else:
            # print("Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎµ Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¯Ï‡Î¹ÏƒÎ· Î³Î¹Î±: ", slot_based_query)
            return []

    # Validation logic to confirm the matched function is appropriate
    if function_to_call not in ['print_collection', 'print_floor']:
        # print(f"The function {function_to_call} may not be suitable for the query: {slot_based_query}")
        return []

    with driver.session() as session:
        if function_to_call == 'print_floor':
            # print("mpike floor!")
            query_exhibition_names, query_exhibition_url = session.read_transaction(print_floor, slot_based_query)
            driver.close()
            return query_exhibition_names, query_exhibition_url

        elif function_to_call == 'print_collection':
            # print("mpike collection!")
            query_exhibition_names = session.read_transaction(print_collection, slot_based_query)
            driver.close()
            return query_exhibition_names

        else:
            # print("Î”ÎµÎ½ Î­Ï‡Ï‰ Î²Î¬Î»ÎµÎ¹ Î±ÎºÏŒÎ¼Î± query Î³Î¹Î±: ", slot_based_query)
            driver.close()
            return []


def has_entity_type(entities, type):
    return any(e for e in entities if e["entity"] == type)


def extract_entity(entities, type1, graph_attr):
    # types = ["married", "wife", "kriti", "vivlio] # enallaktikos tropos diavasmatos twn entities ston parakatw elegxo!
    # p.x. if types[0] and types[1] in query_names:
    # count = 0
    query_names = []
    # Metritis Counter gia na arithmoume ta entities kai na elegxoume ama uparxoun
    for items in entities:
        query_names.append(items["entity"])
        # print(query_names)
        # count += 1
    # print("count: {}".format(count))
    # print("Ta sunolika onomata twn entities einai: {}".format(query_names))
    # print("graph_attr: ", graph_attr)
    # print("graph_attr2: ", graph_attr2)

    # Diladi an den einai empty oi listes logw aniparktwn entities
    # if not len(entities[count-2]['entity']) == 0 and not len(entities[count-1]['entity']) == 0:
    # if entities[count-2] in globals() and entities[count-1] in globals():

    # An uparxoun ta entities "married" kai "wife" dwse tin leksi "ÎÎ¯ÎºÎ¿Ï‚ ÎšÎ±Î¶Î±Î½Ï„Î¶Î¬ÎºÎ·Ï‚" gia na mpei sto slot
    # kai na psaksei to sugkekrimeno query
    # if entities[count-2]['entity'] == type1 and entities[count-1]['entity'] == type2:

    if type1 in query_names:
        return graph_attr
    # elif ...
    #     return "ÎšÏÎ®Ï„Î·"
    else:
        return None

    # if type1 in query_names and type2 not in query_names:
    #     return graph_attr
    # elif type1 in query_names and type2 in query_names:
    #     return graph_attr, graph_attr2
    # # elif ...
    # #     return "ÎšÏÎ®Ï„Î·"
    # else:
    #     return None

    # return [e["value"] for e in entities if e["entity"] == type][0]


class ActionHallExhibitions(Action):
    def name(self) -> Text:
        return "action_hall_exhibitions"

    def run(
            self,
            dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any],
    ) -> List[Dict[Text, Any]]:

        entities = tracker.latest_message.get("entities")

        # has_wife1 = has_entity_type(entities, "type")
        # has_wife2 = has_entity_type(entities, 'type')

        hall = tracker.get_slot('hall')

        collection = tracker.get_slot('collection')

        # if has_wife1 or not has_wife2:
        #     return []

        if hall is None:  # Diladi an einai empty to list logw aniparktwn entities

            return [SlotSet("hall", hall)]
            # return []
        else:

            hall = extract_entity(entities, "hall", hall)

            collection = extract_entity(entities, "collection", collection)

            exhibition_names, url = get_relationship_2_variables(hall, collection)
            # print("exhibition_names: ", exhibition_names)
            # print("url: ", url)

            # books_names = extract_entity(entities, "books_names", books_names_value)
            # print("books_names: ", books_names)
            #
            # query_type2 = get_relationship(book_description)
            # print("query_type: ", query_type2)

            # query_output_complete = get_relationship(wife)
            # print("plan_type: {}".format(query_output_complete))
            # logging.debug(f"wife is {wife}")
            # logging.debug(f"wife is {query_output_complete}")

            # Î Î¹ÏƒÏ„ÎµÏÏ‰ Î´ÎµÎ½ Ï‡ÏÎµÎ¹Î¬Î¶ÎµÏ„Î±Î¹ Î½Î± Î±Ï€Î¿Î¸Î·ÎºÎµÏÎµÏ„Î±Î¹ Ï„Î¿ relation slot Î³Î¹Î±Ï„Î¯ Î´ÎµÎ½ Î¸Î± Î±Î¾Î¹Î¿Ï€Î¿Î¹Î·Î¸ÎµÎ¯ Î¼Î¬Î»Î»Î¿Î½ Ï‰Ï‚ entity ÏƒÎµ Î±Ï€Î±Î½Ï„Î®ÏƒÎµÎ¹Ï‚
            # return [SlotSet("countries", query_countries), SlotSet("relation", relation_value)]
            return [SlotSet("hall", hall),
                    SlotSet("exhibition_names", exhibition_names),
                    SlotSet("url", url),
                    SlotSet("collection", collection)]


class ActionUtterGraphOutputHallExhibitions(Action):
    def name(self) -> Text:
        return "action_utter_graph_output_hall_exhibitions"

    def run(
            self,
            dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any],
    ) -> List[Dict[Text, Any]]:

        # hall = tracker.get_slot('hall')

        collection = tracker.get_slot('collection')

        exhibition_names = tracker.get_slot('exhibition_names')

        # Ama den uparxei timi sto slot, tote pes ston xristi na anadiatiposei
        # Î•Î»Î­Î³Ï‡Ï‰ ÎºÎ±Î¹ Î³Î¹Î± Î¬Î´ÎµÎ¹Î± Î»Î¯ÏƒÏ„Î± Î³Î¹Î±Ï„Î¯ Î¼ÎµÏÎ¹ÎºÎ¬ slots ÎµÎ¯Î½Î±Î¹ lists
        # if (exhibition_names == [None] or exhibition_names == []) and (hall is not None):
        #     dispatcher.utter_message(
        #         f"ğŸ“-> Î¦Î±Î¯Î½ÎµÏ„Î±Î¹ ÏŒÏ„Î¹ Î´ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î± ÎµÎºÎ¸Î­Î¼Î±Ï„Î± Î³Î¹Î± Ï„Î·Î½ Î±Î¯Î¸Î¿Ï…ÏƒÎ± {hall}.")

        # Î¤Î¿ collection ÎµÎ¯Î½Î±Î¹ string ÎµÎ½Ï Ï„Î¿ exhibition_names ÎµÎ¯Î½Î±Î¹ list
        if collection is not None and None not in exhibition_names:
            dispatcher.utter_message(response="utter_hall_exhibitions_collection")
        elif collection is None and None not in exhibition_names:
            dispatcher.utter_message(response="utter_hall_exhibitions")
        else:
            dispatcher.utter_message(response="utter_rephrase")

        return [AllSlotsReset()]


class ActionCollectionExhibitions(Action):
    def name(self) -> Text:
        return "action_collection_exhibitions"

    def run(
            self,
            dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any],
    ) -> List[Dict[Text, Any]]:

        entities = tracker.latest_message.get("entities")

        # has_wife1 = has_entity_type(entities, "type")
        # has_wife2 = has_entity_type(entities, 'type')

        collection = tracker.get_slot('collection')

        # if has_wife1 or not has_wife2:
        #     return []

        if collection is None:  # Diladi an einai empty to list logw aniparktwn entities

            return [SlotSet("collection", collection)]
            # return []
        else:

            collection = extract_entity(entities, "collection", collection)

            exhibition_names = get_relationship_1_variable(collection)
            # print("query_type1: ", exhibition_names)
            # print("query_type2:", url)

            # books_names = extract_entity(entities, "books_names", books_names_value)
            # print("books_names: ", books_names)
            #
            # query_type2 = get_relationship(book_description)
            # print("query_type: ", query_type2)

            # query_output_complete = get_relationship(wife)
            # print("plan_type: {}".format(query_output_complete))
            # logging.debug(f"wife is {wife}")
            # logging.debug(f"wife is {query_output_complete}")

            # Î Î¹ÏƒÏ„ÎµÏÏ‰ Î´ÎµÎ½ Ï‡ÏÎµÎ¹Î¬Î¶ÎµÏ„Î±Î¹ Î½Î± Î±Ï€Î¿Î¸Î·ÎºÎµÏÎµÏ„Î±Î¹ Ï„Î¿ relation slot Î³Î¹Î±Ï„Î¯ Î´ÎµÎ½ Î¸Î± Î±Î¾Î¹Î¿Ï€Î¿Î¹Î·Î¸ÎµÎ¯ Î¼Î¬Î»Î»Î¿Î½ Ï‰Ï‚ entity ÏƒÎµ Î±Ï€Î±Î½Ï„Î®ÏƒÎµÎ¹Ï‚
            # return [SlotSet("countries", query_countries), SlotSet("relation", relation_value)]
            return [SlotSet("exhibition_names", exhibition_names),
                    SlotSet("collection", collection)]


class ActionUtterGraphOutputCollectionExhibitions(Action):
    def name(self) -> Text:
        return "action_utter_graph_output_collection_exhibitions"

    def run(
            self,
            dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any],
    ) -> List[Dict[Text, Any]]:

        collection = tracker.get_slot('collection')

        exhibition_names = tracker.get_slot('exhibition_names')

        # Ama den uparxei timi sto slot, tote pes ston xristi na anadiatiposei
        # Î•Î»Î­Î³Ï‡Ï‰ ÎºÎ±Î¹ Î³Î¹Î± Î¬Î´ÎµÎ¹Î± Î»Î¯ÏƒÏ„Î± Î³Î¹Î±Ï„Î¯ Î¼ÎµÏÎ¹ÎºÎ¬ slots ÎµÎ¯Î½Î±Î¹ lists
        # if (exhibition_names == [None] or exhibition_names == []) and (hall is not None):
        #     dispatcher.utter_message(
        #         f"ğŸ“-> Î¦Î±Î¯Î½ÎµÏ„Î±Î¹ ÏŒÏ„Î¹ Î´ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î± ÎµÎºÎ¸Î­Î¼Î±Ï„Î± Î³Î¹Î± Ï„Î·Î½ Î±Î¯Î¸Î¿Ï…ÏƒÎ± {hall}.")

        # Î¤Î¿ collection ÎµÎ¯Î½Î±Î¹ string ÎµÎ½Ï Ï„Î¿ exhibition_names ÎµÎ¯Î½Î±Î¹ list
        if collection is not None and None not in exhibition_names:
            dispatcher.utter_message(response="utter_collection_exhibitions")
        elif collection is not None and None in exhibition_names:
            dispatcher.utter_message(
                response="ğŸ“-> Î¦Î±Î¯Î½ÎµÏ„Î±Î¹ ÏŒÏ„Î¹ Î´ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î± ÎµÎºÎ¸Î­Î¼Î±Ï„Î± ÏƒÏ„Î· Î²Î¬ÏƒÎ· Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ Î³ÏÎ¬Ï†Î¿Ï… Î³Î¹Î± Ï„Î· ÏƒÏ…Î»Î»Î¿Î³Î® {collection}.")
        else:
            dispatcher.utter_message(response="utter_rephrase")

        return [AllSlotsReset()]


class ActionCollectionExhibitionsAndShowcase(Action):
    def name(self) -> Text:
        return "action_collection_exhibitions_and_showcase"

    def run(
            self,
            dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any],
    ) -> List[Dict[Text, Any]]:

        entities = tracker.latest_message.get("entities")

        # has_wife1 = has_entity_type(entities, "type")
        # has_wife2 = has_entity_type(entities, 'type')

        collection = tracker.get_slot('collection')

        showcase = tracker.get_slot('showcase')

        # if has_wife1 or not has_wife2:
        #     return []

        if collection is None or showcase is None:  # Diladi an einai empty to list logw aniparktwn entities

            return [SlotSet("collection", collection), SlotSet("showcase", showcase)]
            # return []
        else:

            collection = extract_entity(entities, "collection", collection)

            showcase = extract_entity(entities, "showcase", showcase)

            exhibition_names, url = get_relationship_collection_with_showcase(collection, showcase)
            # print("query_type1: ", exhibition_names)
            # print("query_type2:", url)

            # books_names = extract_entity(entities, "books_names", books_names_value)
            # print("books_names: ", books_names)
            #
            # query_type2 = get_relationship(book_description)
            # print("query_type: ", query_type2)

            # query_output_complete = get_relationship(wife)
            # print("plan_type: {}".format(query_output_complete))
            # logging.debug(f"wife is {wife}")
            # logging.debug(f"wife is {query_output_complete}")

            # Î Î¹ÏƒÏ„ÎµÏÏ‰ Î´ÎµÎ½ Ï‡ÏÎµÎ¹Î¬Î¶ÎµÏ„Î±Î¹ Î½Î± Î±Ï€Î¿Î¸Î·ÎºÎµÏÎµÏ„Î±Î¹ Ï„Î¿ relation slot Î³Î¹Î±Ï„Î¯ Î´ÎµÎ½ Î¸Î± Î±Î¾Î¹Î¿Ï€Î¿Î¹Î·Î¸ÎµÎ¯ Î¼Î¬Î»Î»Î¿Î½ Ï‰Ï‚ entity ÏƒÎµ Î±Ï€Î±Î½Ï„Î®ÏƒÎµÎ¹Ï‚
            # return [SlotSet("countries", query_countries), SlotSet("relation", relation_value)]
            return [SlotSet("collection", collection),
                    SlotSet("exhibition_names", exhibition_names),
                    SlotSet("url", url),
                    SlotSet("showcase", showcase)]


class ActionUtterGraphOutputCollectionExhibitionsAndShowcase(Action):
    def name(self) -> Text:
        return "action_utter_graph_output_collection_exhibitions_and_showcase"

    def run(
            self,
            dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any],
    ) -> List[Dict[Text, Any]]:

        collection = tracker.get_slot('collection')

        showcase = tracker.get_slot('showcase')

        exhibition_names = tracker.get_slot('exhibition_names')

        # Ama den uparxei timi sto slot, tote pes ston xristi na anadiatiposei
        # Î•Î»Î­Î³Ï‡Ï‰ ÎºÎ±Î¹ Î³Î¹Î± Î¬Î´ÎµÎ¹Î± Î»Î¯ÏƒÏ„Î± Î³Î¹Î±Ï„Î¯ Î¼ÎµÏÎ¹ÎºÎ¬ slots ÎµÎ¯Î½Î±Î¹ lists
        # if (exhibition_names == [None] or exhibition_names == []) and (hall is not None):
        #     dispatcher.utter_message(
        #         f"ğŸ“-> Î¦Î±Î¯Î½ÎµÏ„Î±Î¹ ÏŒÏ„Î¹ Î´ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î± ÎµÎºÎ¸Î­Î¼Î±Ï„Î± Î³Î¹Î± Ï„Î·Î½ Î±Î¯Î¸Î¿Ï…ÏƒÎ± {hall}.")

        # Î¤Î¿ collection ÎµÎ¯Î½Î±Î¹ string ÎµÎ½Ï Ï„Î¿ exhibition_names ÎµÎ¯Î½Î±Î¹ list
        if (collection is not None and showcase is not None) and exhibition_names is not []:
            dispatcher.utter_message(response="utter_collection_exhibitions_and_showcase")
        elif (collection is not None and showcase is not None) and exhibition_names is []:
            dispatcher.utter_message(
                response="ğŸ“-> Î¦Î±Î¯Î½ÎµÏ„Î±Î¹ ÏŒÏ„Î¹ Î´ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î± ÎµÎºÎ¸Î­Î¼Î±Ï„Î± ÏƒÏ„Î· Î²Î¬ÏƒÎ· Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ Î³ÏÎ¬Ï†Î¿Ï… Î±Ï€ÏŒ Ï„Î· ÏƒÏ…Î»Î»Î¿Î³Î® {collection} Î¼Îµ Î±ÏÎ¹Î¸Î¼ÏŒ {showcase}.")
        else:
            dispatcher.utter_message(response="utter_rephrase")

        return [AllSlotsReset()]


class ActionFloorExhibits(Action):
    def name(self) -> Text:
        return "action_floor_exhibits"

    def run(
            self,
            dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any],
    ) -> List[Dict[Text, Any]]:

        entities = tracker.latest_message.get("entities")

        # has_wife1 = has_entity_type(entities, "type")
        # has_wife2 = has_entity_type(entities, 'type')

        floor = tracker.get_slot('floor')

        # if has_wife1 or not has_wife2:
        #     return []

        if floor is None:  # Diladi an einai empty to list logw aniparktwn entities

            return [SlotSet("floor", floor)]
            # return []
        else:

            floor = extract_entity(entities, "floor", floor)

            exhibition_names, url = get_relationship_1_variable(floor)
            # print("query_type1: ", exhibition_names)
            # print("query_type2:", url)

            # books_names = extract_entity(entities, "books_names", books_names_value)
            # print("books_names: ", books_names)
            #
            # query_type2 = get_relationship(book_description)
            # print("query_type: ", query_type2)

            # query_output_complete = get_relationship(wife)
            # print("plan_type: {}".format(query_output_complete))
            # logging.debug(f"wife is {wife}")
            # logging.debug(f"wife is {query_output_complete}")

            # Î Î¹ÏƒÏ„ÎµÏÏ‰ Î´ÎµÎ½ Ï‡ÏÎµÎ¹Î¬Î¶ÎµÏ„Î±Î¹ Î½Î± Î±Ï€Î¿Î¸Î·ÎºÎµÏÎµÏ„Î±Î¹ Ï„Î¿ relation slot Î³Î¹Î±Ï„Î¯ Î´ÎµÎ½ Î¸Î± Î±Î¾Î¹Î¿Ï€Î¿Î¹Î·Î¸ÎµÎ¯ Î¼Î¬Î»Î»Î¿Î½ Ï‰Ï‚ entity ÏƒÎµ Î±Ï€Î±Î½Ï„Î®ÏƒÎµÎ¹Ï‚
            # return [SlotSet("countries", query_countries), SlotSet("relation", relation_value)]
            return [SlotSet("floor", floor),
                    SlotSet("exhibition_names", exhibition_names),
                    SlotSet("url", url)]


class ActionUtterGraphOutputFloorExhibits(Action):
    def name(self) -> Text:
        return "action_utter_graph_output_floor_exhibits"

    def run(
            self,
            dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any],
    ) -> List[Dict[Text, Any]]:

        floor = tracker.get_slot('floor')

        exhibition_names = tracker.get_slot('exhibition_names')

        # Ama den uparxei timi sto slot, tote pes ston xristi na anadiatiposei
        # Î•Î»Î­Î³Ï‡Ï‰ ÎºÎ±Î¹ Î³Î¹Î± Î¬Î´ÎµÎ¹Î± Î»Î¯ÏƒÏ„Î± Î³Î¹Î±Ï„Î¯ Î¼ÎµÏÎ¹ÎºÎ¬ slots ÎµÎ¯Î½Î±Î¹ lists
        # if (exhibition_names == [None] or exhibition_names == []) and (hall is not None):
        #     dispatcher.utter_message(
        #         f"ğŸ“-> Î¦Î±Î¯Î½ÎµÏ„Î±Î¹ ÏŒÏ„Î¹ Î´ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î± ÎµÎºÎ¸Î­Î¼Î±Ï„Î± Î³Î¹Î± Ï„Î·Î½ Î±Î¯Î¸Î¿Ï…ÏƒÎ± {hall}.")

        # Î¤Î¿ collection ÎµÎ¯Î½Î±Î¹ string ÎµÎ½Ï Ï„Î¿ exhibition_names ÎµÎ¯Î½Î±Î¹ list
        if floor is not None and None not in exhibition_names:
            dispatcher.utter_message(response="utter_floor_exhibits")
        elif floor is not None and None in exhibition_names:
            dispatcher.utter_message(
                response="ğŸ“-> Î¦Î±Î¯Î½ÎµÏ„Î±Î¹ ÏŒÏ„Î¹ Î´ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î± ÎµÎºÎ¸Î­Î¼Î±Ï„Î± ÏƒÏ„Î· Î²Î¬ÏƒÎ· Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ Î³ÏÎ¬Ï†Î¿Ï… Î³Î¹Î± Ï„Î¿Î½ ÏŒÏÎ¿Ï†Î¿ {floor}.")
        else:
            dispatcher.utter_message(response="utter_rephrase")

        return [AllSlotsReset()]


class ActionSetReminder(Action):
    """Schedules a reminder, supplied with the last message's entities."""

    def name(self) -> Text:
        return "action_set_reminder"

    async def run(
            self,
            dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any],
    ) -> List[Dict[Text, Any]]:
        # dispatcher.utter_message("Î˜Î± ÏƒÎµ Ï…Ï€ÎµÎ½Î¸Ï…Î¼Î¯ÏƒÏ‰ 25 Î´ÎµÏ…Ï„ÎµÏÏŒÎ»ÎµÏ€Ï„Î±.")

        date = datetime.datetime.now() + datetime.timedelta(seconds=120)
        # entities = tracker.latest_message.get("entities")

        reminder = ReminderScheduled(
            "EXTERNAL_reminder",
            trigger_date_time=date,
            # entities=entities,
            name="my_reminder",
            kill_on_user_message=True,  # Whether a user message before the trigger time will abort the reminder
        )

        return [reminder]


class ActionReactToReminder(Action):
    """Reminds the user with his name when idle."""

    def name(self) -> Text:
        return "action_react_to_reminder"

    async def run(
            self,
            dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any],
    ) -> List[Dict[Text, Any]]:
        text_list = ["ÎœÎ±Ï‚ Î¾Î­Ï‡Î±ÏƒÎµÏ‚!",
                     "Î•Î¯ÏƒÎ±Î¹ Î±ÎºÏŒÎ¼Î± ÎµÎ´Ï; Î‘Î½ ÏŒÏ‡Î¹, ÏƒÎµ Ï€ÎµÏÎ¹Î¼Î­Î½Î¿Ï…Î¼Îµ ÏƒÏ„Î¿ Î¼Î¿Ï…ÏƒÎµÎ¯Î¿!",
                     "Î•Î¯Î¼Î±Î¹ ÎµÎ´Ï Î±ÎºÏŒÎ¼Î±, Î­Ï„Î¿Î¹Î¼Î¿Ï‚ Î½Î± Î±ÎºÎ¿ÏÏƒÏ‰ Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ± Î±Ï€ÏŒ ÎµÏƒÎ­Î½Î±!",
                     "Î•Î¯Î¼Î±Î¹ ÎµÎ´Ï Î±ÎºÏŒÎ¼Î±, Î­Î»Î± Î½Î± ÏƒÏ…Î½ÎµÏ‡Î¯ÏƒÎ¿Ï…Î¼Îµ Ï„Î·Î½ ÎºÎ¿Ï…Î²Î­Î½Ï„Î± Î¼Î±Ï‚!",
                     "Î‘Î½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ ÎºÎ¬Ï„Î¹ Ï€Î¿Ï… Î¸Î­Î»ÎµÎ¹Ï‚ Î½Î± ÏƒÏ…Î¶Î·Ï„Î®ÏƒÎ¿Ï…Î¼Îµ, ÎµÎ¯Î¼Î±Î¹ ÎµÎ´Ï Î³Î¹Î± Î½Î± ÏƒÎµ Î²Î¿Î·Î¸Î®ÏƒÏ‰!"]

        random_text = random.choice(text_list)

        dispatcher.utter_message(random_text)

        return []


class ActionSetReminderCollections(Action):
    """Schedules a reminder, supplied with the last message's entities."""

    def name(self) -> Text:
        return "action_set_reminder_collections"

    async def run(
            self,
            dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any],
    ) -> List[Dict[Text, Any]]:
        # dispatcher.utter_message("Î˜Î± ÏƒÎµ Ï…Ï€ÎµÎ½Î¸Ï…Î¼Î¯ÏƒÏ‰ 25 Î´ÎµÏ…Ï„ÎµÏÏŒÎ»ÎµÏ€Ï„Î±.")

        date = datetime.datetime.now() + datetime.timedelta(seconds=30)
        # entities = tracker.latest_message.get("entities")

        reminder = ReminderScheduled(
            "EXTERNAL_reminder_collections",
            trigger_date_time=date,
            # entities=entities,
            name="my_reminder_collections",
            kill_on_user_message=True,  # Whether a user message before the trigger time will abort the reminder
        )

        return [reminder]


class ActionReactToReminderCollections(Action):
    """Reminds the user with his name when idle."""

    def name(self) -> Text:
        return "action_react_to_reminder_collections"

    async def run(
            self,
            dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any],
    ) -> List[Dict[Text, Any]]:
        text = 'ÎœÎ·Î½ Î¾ÎµÏ‡Î½Î¬Ï‚, Î¼Ï€Î¿ÏÎµÎ¯Ï‚ Î½Î± Î¼Îµ ÏÏ‰Ï„Î®ÏƒÎµÎ¹Ï‚ Î³Î¹Î± Ï„Î± ÎµÎºÎ¸Î­Î¼Î±Ï„Î± Ï„Î¿Ï… Î¼Î¿Ï…ÏƒÎµÎ¯Î¿Ï… Î® Î½Î± ÎµÏ€Î¹Î»Î­Î¾ÎµÎ¹Ï‚ Ï„Î·Î½ ÎµÏ€Î¹Î»Î¿Î³Î® "Î•ÎºÎ¸Î­Î¼Î±Ï„Î±" Î±Ï€ÏŒ Ï„Î·Î½ Î±Î½Ï„Î¯ÏƒÏ„Î¿Î¹Ï‡Î· ÏƒÏ…Î»Î»Î¿Î³Î®!'

        dispatcher.utter_message(text)

        return []


class ActionCreateCollectionsCarousels(Action):
    def name(self) -> Text:
        return "action_create_collections_carousels"

    def run(
            self,
            dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any],
    ) -> List[Dict[Text, Any]]:
        dispatcher.utter_message(
            text='ÎšÎ±Î»ÏÏ‚ Î®ÏÎ¸Î±Ï„Îµ ÏƒÏ„Î¿Î½ ÏˆÎ·Ï†Î¹Î±ÎºÏŒ Î²Î¿Î·Î¸ÏŒ Î³Î¹Î± Ï„Î¹Ï‚ ÏƒÏ…Î»Î»Î¿Î³Î­Ï‚ ÎºÎ±Î¹ Ï„Î± ÎµÎºÎ¸Î­Î¼Î±Ï„Î± Ï„Î¿Ï… Î¼Î¿Ï…ÏƒÎµÎ¯Î¿Ï… "ÎÎ¯ÎºÎ¿Ï‚ ÎšÎ±Î¶Î±Î½Ï„Î¶Î¬ÎºÎ·Ï‚". ÎˆÎ½Î±Ï‚ Î­Î¾Ï…Ï€Î½Î¿Ï‚ Î³ÏÎ¬Ï†Î¿Ï‚ Î³Î½ÏÏƒÎ·Ï‚ ÎµÎ¯Î½Î±Î¹ ÏƒÏ…Î½Î´ÎµÎ´ÎµÎ¼Î­Î½Î¿Ï‚ Î¼Îµ Ï„Î¿Î½ ÏˆÎ·Ï†Î¹Î±ÎºÏŒ Î²Î¿Î·Î¸ÏŒ Î³Î¹Î± Ï„Î·Î½ Ï€Î±ÏÎ¿Ï‡Î® Ï€Î¹Î¿ ÎµÎ¾ÎµÎ¹Î´Î¹ÎºÎµÏ…Î¼Î­Î½Ï‰Î½ Ï€Î»Î·ÏÎ¿Ï†Î¿ÏÎ¹ÏÎ½ ÏƒÏ‡ÎµÏ„Î¹ÎºÎ¬ Î¼Îµ Ï„Î± ÎµÎºÎ¸Î­Î¼Î±Ï„Î± Ï„Î¿Ï… Î¼Î¿Ï…ÏƒÎµÎ¯Î¿Ï….')

        # Î¤Î± keys Î³Î¹Î± Ï„Î¿ json Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ ÏƒÏ„Î¿ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰ link
        # https://github.com/botfront/rasa-webchat/blob/010c0539a6c57c426d090c7c8c1ca768ec6c81dc/src/components/Widget/components/Conversation/components/Messages/components/Carousel/index.js
        message = {
            "type": "template",
            "payload": {
                "template_type": "generic",
                "elements": [
                    {
                        "title": "Î’Î¹Î¿Î³ÏÎ±Ï†Î¹ÎºÎ¬ ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î±",
                        "subtitle": "Î Î±Î¹Î´Î¹ÎºÎ¬ Ï‡ÏÏŒÎ½Î¹Î±, Î£ÏÎ¶Ï…Î³Î¿Î¹, Î¦Î¯Î»Î¿Î¹, Î ÏÎ¿ÏƒÏ‰Ï€Î¹ÎºÎ¬ Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î±",
                        "image_url": "https://www.memobot.eu/wp-content/uploads/2022/10/Î²Î¹Î¿Î³ÏÎ±Ï†Î¹ÎºÎ¬-ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î±.jpg",
                        "buttons": [
                            {
                                "title": "ÎœÎ¬Î¸Îµ Î³Î¹Î± Ï„Î·Î½ ÏƒÏ…Î»Î»Î¿Î³Î®",
                                "payload": "/viografika_stoixeia",
                                "type": "postback"
                            },
                            {
                                "title": "Î•ÎºÎ¸Î­Î¼Î±Ï„Î±",
                                "payload": "Î•ÎºÎ¸Î­Î¼Î±Ï„Î± Î±Î¯Î¸Î¿Ï…ÏƒÎ±Ï‚ Î’Î¹Î¿Î³ÏÎ±Ï†Î¹ÎºÎ¬",
                                "type": "postback"
                            },
                        ]
                    },
                    {
                        "title": "Î— 'ÎŸÎ´ÏÏƒÎµÎ¹Î±'",
                        "subtitle": "ÎœÎµÎ³Î±Î»ÏŒÏ€Î½Î¿Î¿ Î­Ï€Î¿Ï‚ Ï„Î¿Ï… ÎšÎ±Î¶Î±Î½Ï„Î¶Î¬ÎºÎ·",
                        "image_url": "https://www.memobot.eu/wp-content/uploads/2022/10/Î¿Î´ÏÏƒÏƒÎµÎ¹Î±.jpg",
                        "buttons": [
                            {
                                "title": "ÎœÎ¬Î¸Îµ Î³Î¹Î± Ï„Î·Î½ ÏƒÏ…Î»Î»Î¿Î³Î®",
                                "payload": "/odusseia",
                                "type": "postback"
                            },
                            {
                                "title": "Î•ÎºÎ¸Î­Î¼Î±Ï„Î±",
                                "payload": "Î•ÎºÎ¸Î­Î¼Î±Ï„Î± Î±Î¯Î¸Î¿Ï…ÏƒÎ±Ï‚ ÎŸÎ´ÏÏƒÏƒÎµÎ¹Î±",
                                "type": "postback"
                            },
                        ]
                    },
                    {
                        "title": "Î•Ï€Î¹ÏÏÎ¿Î­Ï‚",
                        "subtitle": "Î•Ï€Î¹ÏƒÏ„Î¿Î»Î­Ï‚ & Î ÏÎ¿ÏƒÏ‰ÏÎ¹Î½Î¬ ÎµÎºÎ¸Î­Î¼Î±Ï„Î± ",
                        "image_url": "https://www.memobot.eu/wp-content/uploads/2022/10/Ï†Î¹Î»Î¿Î¹-Îº-ÎµÏ€Î¹ÏÏÎ¿ÎµÏ‚-1024x681-1.jpg",
                        "buttons": [
                            {
                                "title": "ÎœÎ¬Î¸Îµ Î³Î¹Î± Ï„Î·Î½ ÏƒÏ…Î»Î»Î¿Î³Î®",
                                "payload": "/filoi_epirroes",
                                "type": "postback"
                            },
                            {
                                "title": "Î•ÎºÎ¸Î­Î¼Î±Ï„Î±",
                                "payload": "Î•ÎºÎ¸Î­Î¼Î±Ï„Î± Î±Î¯Î¸Î¿Ï…ÏƒÎ±Ï‚ Î¦Ï‰Ï„Î¿Î³ÏÎ±Ï†Î¹ÎºÏŒ Î‘ÏÏ‡ÎµÎ¯Î¿",
                                "type": "postback"
                            },
                        ]
                    },
                    {
                        "title": "Î ÏÏÎ¹Î¼Î± Î­ÏÎ³Î±",
                        "subtitle": "Î˜ÎµÎ±Ï„ÏÎ¹ÎºÎ¬, Î Î±Î¹Î´Î¹ÎºÎ¬ Î²Î¹Î²Î»Î¯Î± ÎºÎ±Î¹ Î· 'Î‘ÏƒÎºÎ·Ï„Î¹ÎºÎ®'",
                        "image_url": "https://www.memobot.eu/wp-content/uploads/2022/10/Ï€ÏÏÎ¹Î¼Î±-Î¸ÎµÎ±Ï„ÏÎ¹ÎºÎ¬-ÎµÏÎ³Î±.jpg",
                        "buttons": [
                            {
                                "title": "ÎœÎ¬Î¸Îµ Î³Î¹Î± Ï„Î·Î½ ÏƒÏ…Î»Î»Î¿Î³Î®",
                                "payload": "/proima_theatrika",
                                "type": "postback"
                            },
                            # {
                            #     "title": "Î•ÎºÎ¸Î­Î¼Î±Ï„Î±",
                            #     "payload": "Î•ÎºÎ¸Î­Î¼Î±Ï„Î± Î±Î¯Î¸Î¿Ï…ÏƒÎ±Ï‚ ------",
                            #     "type": "postback"
                            # },
                        ]
                    },
                    {
                        "title": "ÎœÏ…Î¸Î¹ÏƒÏ„Î¿ÏÎ®Î¼Î±Ï„Î±",
                        "subtitle": "'Î¤Î±Î¾Î¹Î´ÎµÏÎ¿Î½Ï„Î±Ï‚...', Î‘Î½Î±Î³Î½Ï‰ÏƒÏ„Î®ÏÎ¹Î¿, Î£Î¹Î½ÎµÎ¼Î¬, Î Î¿Î»Î¹Ï„Î¹ÎºÎ® ÎºÎ±Î¹ Î¼ÎµÎ»Î­Ï„ÎµÏ‚ Î³Î¹Î± Ï„Î¿Î½ ÎšÎ±Î¶Î±Î½Ï„Î¶Î¬ÎºÎ·",
                        "image_url": "https://www.memobot.eu/wp-content/uploads/2022/10/Î¼Ï…Î¸Î¹ÏƒÏ„Î¿ÏÎ·Î¼Î±Ï„Î±-1024x511-1.jpg",
                        "buttons": [
                            {
                                "title": "ÎœÎ¬Î¸Îµ Î³Î¹Î± Ï„Î·Î½ ÏƒÏ…Î»Î»Î¿Î³Î®",
                                "payload": "/mithistorimata",
                                "type": "postback"
                            },
                            {
                                "title": "Î•ÎºÎ¸Î­Î¼Î±Ï„Î±",
                                "payload": "Î•ÎºÎ¸Î­Î¼Î±Ï„Î± Î±Î¯Î¸Î¿Ï…ÏƒÎ±Ï‚ ÎœÏ…Î¸Î¹ÏƒÏ„Î¿ÏÎ®Î¼Î±Ï„Î±",
                                "type": "postback"
                            },
                        ]
                    }
                ]
            }
        }

        dispatcher.utter_message(attachment=message)

        return []


class ActionGoodbye(Action):
    """Goodbyes the user with his name."""

    def name(self) -> Text:
        return "action_goodbye"

    async def run(
            self,
            dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any],
    ) -> List[Dict[Text, Any]]:
        text_list = ["Î‘Î½Ï„Î¯Î¿, ÏƒÎµ ÎµÏ…Ï‡Î±ÏÎ¹ÏƒÏ„Î¿ÏÎ¼Îµ Î³Î¹Î± Ï„Î·Î½ ÎµÏ€Î¯ÏƒÎºÎµÏˆÎ·. ğŸ™‚",
                     "Î‘Î½Ï„Î¯Î¿, Î¸Î± ÏƒÎµ Ï€ÎµÏÎ¹Î¼Î­Î½Î¿Ï…Î¼Îµ ÏƒÏ„Î¿ ÎœÎ¿Ï…ÏƒÎµÎ¯Î¿. ğŸ™‚"]

        random_text = random.choice(text_list)

        dispatcher.utter_message(random_text)

        return []
